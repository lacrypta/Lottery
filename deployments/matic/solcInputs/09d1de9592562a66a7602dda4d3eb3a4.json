{
  "language": "Solidity",
  "sources": {
    "contracts/ILottery.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.17;\n\n/**\n * Blockchain-based Lottery\n *\n * This interface allows you to interact with a blockchain-based lottery able to deal several prizes to a given population.\n * All the inputs needed to reproduce the result are persisted in the blockchain, so as to be auditable and reproducible.\n *\n *\n * The Lottery works like so:\n *   - a new Lottery must be created, in order to do so, you need a name for it, the seed to use, the participant population\n *     as a list of strings, and the number of prizes that will be dealt\n *   - once the lottery is created, exists(name) will return true, and get(name) will return a structure representing the seed to\n *     use, the population, and the number of prizes\n *   - finally, with a created lottery, calling winners(name) will return the prize winners in no particular order.\n *   - alternatively, the simulate(config) method can be called to obtain the winners without persisting anything on the\n *     blockchain.\n *\n * Let's follow along a simple example.\n * We want to create a Lottery that will deal 5 prizes amongst 100 participants, using a zero seed, we'll call it \"Doing the\n * dishes for 100 dudes\".\n *\n * We first need to call (we'll use \">>>\" to denote calls, and \"<<<\" responses):\n *\n *   >>> create(\"Doing the dishes for 100 dudes\", [\"0x00...0\", 5, [\"one\", \"two\", ..., \"one hundred\"]])\n *   <<< bool: success true\n *\n * Now we can check whether it was indeed created by doing:\n *\n *   >>> exists(\"Doing the dishes for 100 dudes\")\n *   <<< bool: existing true\n *\n * and retrieve the Lottery's parameters by:\n *\n *   >>> get(\"Doing the dishes for 100 dudes\")\n *   <<< tuple(bytes32,uint256,string[]): lottery 0x00...0,5,[\"one\",\"two\",...,\"one hundred\"]\n *\n * (see how this is the same data the create() call returns).\n * Finally, we can retrieve the unlucky winners by calling:\n *\n *   >>> winners(\"Doing the dishes for 100 dudes\")\n *   <<< string[]: winners \"nineteen\",\"twenty-three\",\"sixty-six\",\"ninety-two\",\"ninety-nine\"\n *\n * this means that participants 19, 23, 66, 92, and 99 won the coveted responsibility of doing the dishes.\n *\n *\n * Notice that once the Lottery is created, the winners are all implicitly determined automatically, and persisted in the blockchain\n * for all to see and audit.\n */\ninterface ILottery {\n\n    /**\n     * Raised upon encountering a non-existing lottery name\n     *\n     * @param name  The offending name\n     */\n    error NotYetCreated(string name);\n\n    /**\n     * Raised upon encountering an already-existing lottery name\n     *\n     * @param name  The offending name\n     */\n    error NameAlreadyInUse(string name);\n\n    /**\n     * Raised upon encountering an empty players list\n     *\n     */\n    error PlayersMustBeNonEmpty();\n\n    /**\n     * Raised upon encountering a 0-size selection (ie. the number of winners)\n     *\n     */\n    error NumberOfWinnersMustBePositive();\n\n    /**\n     * Raised upon encountering a number of winners greater than the corresponding population\n     *\n     * @param numberOfPlayers  The offending number of players\n     * @param numberOfWinners  The offending number of winners\n     */\n    error NumberOfWinnersMustBeAtMostNumberOfPlayers(uint256 numberOfPlayers, uint256 numberOfWinners);\n\n    /**\n     * Structure representing a lottery configuration\n     *\n     * @custom:member seed  The RNG seed to use for this lottery\n     * @custom:member numberOfWinners  The number of winners to use for this lottery\n     * @custom:member players  A list of players for this lottery (this list CAN contain duplicates to simulate non-uniform odds)\n     */\n    struct Config {\n        bytes32 seed;\n        uint256 numberOfWinners;\n        string[] players;\n    }\n\n    /**\n     * Build a lottery configuration from the given parameters\n     *\n     * @param seed  The RNG seed to use\n     * @param numberOfWinners  The number of winners to use\n     * @param players  A list of players to use\n     * @return config  The constructed configuration\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function build(bytes32 seed, uint256 numberOfWinners, string[] memory players) external pure returns (Config memory config);\n\n    /**\n     * Determine whether the given lottery name exists\n     *\n     * @param name  Lottery name to check\n     * @return existing  True if the given lottery name exists, false otherwise\n     */\n    function exists(string memory name) external view returns (bool existing);\n\n    /**\n     * Retrieve an existing lottery by name\n     *\n     * @param name  Lottery name to retrieve\n     * @return lottery  The lottery configuration proper\n     * @custom:revert  NotYetCreated\n     */\n    function get(string memory name) external view returns (Config memory lottery);\n\n    /**\n     * Create a new lottery with the given configuration\n     *\n     * @param name  Lottery name to use\n     * @param config  Lottery configuration to use\n     * @return success  True if creation was successful\n     * @custom:revert  NameAlreadyInUse\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function create(string memory name, Config memory config) external returns (bool success);\n\n    /**\n     * Create a new lottery with the given configuration parts\n     *\n     * @param name  Lottery name to use\n     * @param seed  The RNG seed to use\n     * @param numberOfWinners  The number of winners to use\n     * @param players  A list of players to use\n     * @return success  True if creation was successful\n     * @custom:revert  NameAlreadyInUse\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function create(string memory name, bytes32 seed, uint256 numberOfWinners, string[] memory players) external returns (bool success);\n\n    /**\n     * Retrieve the list of winners\n     *\n     * @param name  Lottery name to retrieve winners for\n     * @return prizeWinners  List of winners\n     * @custom:revert  NotYetCreated\n     */\n    function winners(string memory name) external view returns (string[] memory prizeWinners);\n\n    /**\n     * Simulate the execution of the given lottery configuration\n     *\n     * @param config  Lottery configuration to use\n     * @return prizeWinners  List of winners\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function simulate(Config memory config) external pure returns (string[] memory prizeWinners);\n\n    /**\n     * Simulate the execution of the given lottery configuration parts\n     *\n     * @param seed  The RNG seed to use\n     * @param numberOfWinners  The number of winners to use\n     * @param players  A list of players to use\n     * @return prizeWinners  List of winners\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function simulate(bytes32 seed, uint256 numberOfWinners, string[] memory players) external pure returns (string[] memory prizeWinners);\n}\n"
    },
    "contracts/Lottery.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {ILottery} from \"./ILottery.sol\";\n\n/**\n * Blockchain-based Lottery Implementation\n *\n * This Lottery implementation uses iterated Keccak256 as the underlying RNG.\n *\n */\ncontract Lottery is ILottery {\n\n    /**\n     * Mapping from hashed lottery name to lottery configuration\n     *\n     */\n    mapping(bytes32 => Config) internal _lotteries;\n\n    /**\n     * Build a lottery configuration from the given parameters\n     *\n     * @param seed  The RNG seed to use\n     * @param numberOfWinners  The number of winners to use\n     * @param players  A list of players to use\n     * @return config  The constructed configuration\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function build(bytes32 seed, uint256 numberOfWinners, string[] memory players) external pure override returns (Config memory config) {\n        config = _build(seed, numberOfWinners, players);\n    }\n\n    /**\n     * Determine whether the given lottery name exists\n     *\n     * @param name  Lottery name to check\n     * @return existing  True if the given lottery name exists, false otherwise\n     */\n    function exists(string memory name) external view override returns (bool existing) {\n        existing = (0 != _lotteries[_nameHash(name)].players.length);\n    }\n\n    /**\n     * Retrieve an existing lottery by name\n     *\n     * @param name  Lottery name to retrieve\n     * @return lottery  The lottery configuration proper\n     * @custom:revert  NotYetCreated\n     */\n    function get(string memory name) external view override returns (Config memory lottery) {\n        lottery = _get(name);\n    }\n\n    /**\n     * Create a new lottery with the given configuration\n     *\n     * @param name  Lottery name to use\n     * @param config  Lottery configuration to use\n     * @return success  True if creation was successful\n     * @custom:revert  NameAlreadyInUse\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function create(string memory name, Config memory config) external override returns (bool success) {\n        success = _create(name, _validate(config));\n    }\n\n    /**\n     * Create a new lottery with the given configuration parts\n     *\n     * @param name  Lottery name to use\n     * @param seed  The RNG seed to use\n     * @param numberOfWinners  The number of winners to use\n     * @param players  A list of players to use\n     * @return success  True if creation was successful\n     * @custom:revert  NameAlreadyInUse\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function create(string memory name, bytes32 seed, uint256 numberOfWinners, string[] memory players) external override returns (bool success) {\n        success = _create(name, _build(seed, numberOfWinners, players));\n    }\n\n    /**\n     * Retrieve the list of winners\n     *\n     * @param name  Lottery name to retrieve winners for\n     * @return prizeWinners  List of winners\n     * @custom:revert  NotYetCreated\n     */\n    function winners(string memory name) external view override returns (string[] memory prizeWinners) {\n        prizeWinners = _winners(_get(name));\n    }\n\n    /**\n     * Simulate the execution of the given lottery configuration\n     *\n     * @param config  Lottery configuration to use\n     * @return prizeWinners  List of winners\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function simulate(Config memory config) external pure override returns (string[] memory prizeWinners) {\n        prizeWinners = _winners(_validate(config));\n    }\n\n    /**\n     * Simulate the execution of the given lottery configuration parts\n     *\n     * @param seed  The RNG seed to use\n     * @param numberOfWinners  The number of winners to use\n     * @param players  A list of players to use\n     * @return prizeWinners  List of winners\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function simulate(bytes32 seed, uint256 numberOfWinners, string[] memory players) external pure override returns (string[] memory prizeWinners) {\n        prizeWinners = _winners(_build(seed, numberOfWinners, players));\n    }\n\n    /**\n     * Structure representing the internal state of the underlying RNG\n     *\n     * @custom:member state  The internal state (to be returned iteratively)\n     * @custom:member index  The current bit position being returned\n     * @custom:member round  The number of hash iterations done so far, incremented each time the state needs to be hashed\n     */\n    struct _Rng {\n        bytes32 state;\n        uint8 index;\n        uint256 round;\n    }\n\n    /**\n     * Build a lottery configuration from the given parameters (internal)\n     *\n     * @param seed  The RNG seed to use\n     * @param numberOfWinners  The number of winners to use\n     * @param players  A list of players to use\n     * @return config  The constructed configuration\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function _build(bytes32 seed, uint256 numberOfWinners, string[] memory players) internal pure returns (Config memory config) {\n        config = _validate(Config(seed, numberOfWinners, players));\n    }\n\n    /**\n     * Validate the given lottery configuration\n     *\n     * @param config  Lottery configuration to validate\n     * @return ok  The given configuration, if valid\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function _validate(Config memory config) internal pure returns (Config memory ok) {\n        if (0 == config.players.length) {\n            revert PlayersMustBeNonEmpty();\n        }\n        if (0 == config.numberOfWinners) {\n            revert NumberOfWinnersMustBePositive();\n        }\n        if (config.players.length < config.numberOfWinners) {\n            revert NumberOfWinnersMustBeAtMostNumberOfPlayers(config.players.length, config.numberOfWinners);\n        }\n        ok = config;\n    }\n\n    /**\n     * Compute the hashed lottery name\n     *\n     * @param name  The lottery name to hash\n     * @return nameHash  The hashed lottery name\n     */\n    function _nameHash(string memory name) internal pure returns (bytes32 nameHash) {\n        nameHash = keccak256(bytes(name));\n    }\n\n    /**\n     * Retrieve an existing lottery by name (internal)\n     *\n     * @param name  Lottery name to retrieve\n     * @return lottery  The lottery configuration proper\n     * @custom:revert  NotYetCreated\n     */\n    function _get(string memory name) internal view returns (Config memory lottery) {\n        bytes32 nameHash = _nameHash(name);\n        if (0 == _lotteries[nameHash].players.length) {\n            revert NotYetCreated(name);\n        }\n        lottery = _lotteries[nameHash];\n    }\n\n    /**\n     * Create a new lottery with the given configuration (internal)\n     *\n     * @param name  Lottery name to use\n     * @param config  Lottery configuration to use\n     * @return success  True if creation was successful\n     * @custom:revert  NameAlreadyInUse\n     * @custom:revert  PlayersMustBeNonEmpty\n     * @custom:revert  NumberOfWinnersMustBePositive\n     * @custom:revert  NumberOfWinnersMustBeAtMostNumberOfPlayers\n     */\n    function _create(string memory name, Config memory config) internal returns (bool success) {\n        bytes32 nameHash = _nameHash(name);\n        if (0 != _lotteries[nameHash].players.length) {\n            revert NameAlreadyInUse(name);\n        }\n        _lotteries[nameHash] = config;\n        return true;\n    }\n\n    /**\n     * Retrieve the list of winners (internal)\n     *\n     * Winner retrieval entails creating a permutation of the first `config.players.length` numbers, and taking `config.numberOfWinners` many.\n     * This ensures _uniform_ selection.\n     *\n     * In order to create the truncated permutation proper, the Fisher--Yates algorithm is run until `config.numberOfWinners` items have been\n     * generated.\n     * In order to feed the Fisher--yates algorithm, the FDR algorithm is used.\n     *\n     *\n     * @param config  Lottery configuration to use\n     * @return prizeWinners  List of winners\n     */\n    function _winners(Config memory config) internal pure returns (string[] memory prizeWinners) {\n        unchecked {\n            uint256[] memory winnerIds = _fisherYatesUpTo(_Rng(config.seed, 0, 0), config.players.length, config.numberOfWinners);\n            prizeWinners = new string[](config.numberOfWinners);\n            for (uint256 i = 0; i < config.numberOfWinners; i++) {\n                prizeWinners[i] = config.players[winnerIds[i]];\n            }\n        }\n    }\n\n    /**\n     * Inside-out Fisher--Yates algorithm that only continues until the given number of members\n     *\n     * @custom:ref  \"Fisher--Yates inside-out algorithm\" https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_%22inside-out%22_algorithm\n     * @param rng  The RNG to use\n     * @param size  The number of elements in total\n     * @param until  The number of elements to generate\n     * @return elements  The generated permutation\n     */\n    function _fisherYatesUpTo(_Rng memory rng, uint256 size, uint256 until) internal pure returns (uint256[] memory elements) {\n        unchecked {\n            uint256[] memory values = new uint256[](size);\n            for (uint256 i = 0; i < size; i++) {\n                values[i] = i;\n            }\n            elements = new uint256[](until);\n            for (uint256 i = 0; i < until; i++) {\n                uint256 j = i + _fdr(rng, size - i);\n                (elements[i], values[j]) = (values[j], values[i]);\n            }\n        }\n    }\n\n    /**\n     * Return a uniformly random integer between 0 (inclusive) and `max` (exclusive), using the given RNG\n     *\n     * This algorithm implements the FDR algorithm of Lumbroso.\n     *\n     * @custom:ref \"Optimal Discrete Uniform Generation from Coin Flips, and Applications --- J\\u00e9r\\u00e9mie Lumbroso (2013)\" https://arxiv.org/pdf/1304.1916\n     * @param rng  The RNG to use\n     * @param max  The maximum (exclusive) to generate\n     * @return value  The generated number\n     */\n    function _fdr(_Rng memory rng, uint256 max) internal pure returns (uint256 value) {\n        unchecked {\n            uint256 limit = 1;\n            while (true) {\n                (limit, value) = (limit << 1, (value << 1) + _getBit(rng));\n                if (max <= limit) {\n                    if (value < max) {\n                        break;\n                    } else {\n                        (limit, value) = (limit - max, value - max);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Retrieve a bit out of the given RNG\n     *\n     * @param rng  The RNG to use\n     * @return bit  The extracted bit as a number\n     */\n    function _getBit(_Rng memory rng) internal pure returns (uint256 bit) {\n        unchecked {\n            if (0 == rng.index) {\n                rng.state = keccak256(abi.encodePacked(rng.state, rng.round++));\n            }\n            bit = (0 != (uint8(rng.state[rng.index >> 3]) & (uint8(1) << (rng.index % 8)))) ? 1 : 0;\n            rng.index++;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "peephole": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true,
        "yul": true,
        "yulDetails": {
          "stackAllocation": true
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}